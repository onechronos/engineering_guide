# The Software Development Process (SDP)

Everything hard about developing and evolving software from a pure engineering standpoint amounts to understanding the problem domain. Given a perfect model of said domain, everything else about developing software is easy. For one, estimating the time required to build a new feature in a world where models are fully specified is straightforward. New features have no blockers or requirements that make implementing them "hard;" in a fully specified domain, all possibilities live within the domain awaiting implementation. As such, the existing systems on which they're built accounted for their future existence. Any new system built specifically to support a new feature will also prove straightforward. Why? That system is also blocker-free, given a recursive application of the antecedent argument.

This panacea is far from a reality. The problem domain is almost never known in entirety, and systems inevitably evolve in ways that are unforeseeable. As such, implementing new features is typically an exercise in modifying existing systems to accommodate new ones. Dependencies are often uncovered sequentially; this leads to "project dependency hell" whereby simple feature request turn into massive engineering undertakings, the scale of which is hard to predict upfront.

The transitive dependences unearthed are "unknown unknowns," and more often than not they result from a mix of purely technical challenges and model misspecification. Technical dependencies are of the form "we need to change __X__ to accommodate __Y__, but doing that would break __Z__, so now we need to refactor __X__ and __Z__. Oh, if we change the ```fooBar()``` method of __Z__, __A__ breaks...which in turn breaks..." Heading into to the project, you *might* know about the dependency of __X__ on __Y__, but the deeper the dependency chain gets, the less foreseeable issues become. Model misspecifications result from misunderstandings - teams delivering functionality as specified, but the spec itself being incorrect or deficient. These conversations are typically of the form "Oh, yea, actually the report needs to include this column too" or "Oh, when I said that customers should be able to do __X__, I didn't mean brokers." This can result in new dependencies, and a vicious cycle. When stakeholders aren't totally aligned on requirements, the problem is acute.

The best weapons for fighting dependency hell are the use of a Ubiquitous Language and thoughtful domain modeling/isolation. Involving all stakeholders in the design process and using a Ubiquitous Language is the best way to ensure that everyone is in sync about what the requirements actually are. Domain modeling and Bounded Contexts let systems evolve independently. We'll discuss these topics in detail when we cover [Domain Driven Design (DDD)](../ddd/index.md) in detail.
